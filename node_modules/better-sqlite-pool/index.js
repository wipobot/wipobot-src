"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = void 0;
const events_1 = require("events");
const BetterSqlite3 = require("better-sqlite3");
const isV7 = parseInt(require("better-sqlite3/package.json").version) >= 7;
const releaseEvent = "release";
class Pool extends events_1.EventEmitter {
    /**
     * Creates a new pool to store database connections.
     *
     * @param path A SQLite database file path, can be set to
     *  `:memory` to open a memory based database.
     * @param options If this argument is set to a boolean, it's equivalent to
     *  `readonly`, if set to a number, it's equivalent to `max`.
     *
     * @see https://github.com/JoshuaWise/better-sqlite3/wiki/API#new-databasepath-options
     */
    constructor(path, options) {
        super();
        this.readonly = false;
        this.fileMustExist = false;
        this.timeout = 5000;
        this.max = 5;
        this.connections = [];
        this._closed = false;
        if (options === undefined || options === null) {
            options = {};
        }
        else if (typeof options === "boolean") {
            options = { readonly: options };
        }
        else if (typeof options === "number") {
            options = { max: options };
        }
        Object.assign(this, {
            path,
            memory: path === ":memory",
            verbose: null,
        }, options);
    }
    /**
     * Acquires a connection from the pool.
     * @see https://github.com/JoshuaWise/better-sqlite3/wiki/API#class-database
     */
    acquire() {
        if (this._closed) {
            throw new Error("Database already closed");
        }
        const conn = this._getAvailableConnection()
            || this._createConnection();
        if (conn) {
            return Promise.resolve(conn);
        }
        else {
            return this._waitConnection();
        }
    }
    _getAvailableConnection() {
        for (let conn of this.connections) {
            if (conn.available && conn.open) {
                Object.assign(conn, {
                    available: false,
                });
                return conn;
            }
        }
        return null;
    }
    _createConnection() {
        if (this.connections.length < this.max) {
            let conn = this._rawCreateConnection();
            Object.assign(conn, {
                available: false,
            });
            conn.release = () => {
                if (conn.open && conn.inTransaction)
                    conn.exec("rollback");
                if (this._closed) {
                    conn.close();
                }
                else {
                    Object.assign(conn, {
                        available: conn.open && true,
                    });
                    this.emit(releaseEvent);
                }
            };
            if (this.onConnectionCreated) {
                this.onConnectionCreated(conn);
            }
            this.connections.push(conn);
            return conn;
        }
        return null;
    }
    /**
     * low level create connection
     * TODO: this should be abstract method for universal Database Pool
     */
    _rawCreateConnection() {
        const options = {
            "readonly": this.readonly,
            "fileMustExist": this.fileMustExist,
            "timeout": this.timeout,
            "verbose": this.verbose,
        };
        if (isV7) {
            Object.assign(options, { [":memory"]: this.memory });
        }
        else {
            Object.assign(options, { memory: this.memory });
        }
        return new BetterSqlite3(this.path, options);
    }
    _waitConnection() {
        return new Promise((resolve, reject) => {
            const handler = () => {
                clearTimeout(timer);
                resolve(this.acquire());
            };
            const timer = setTimeout(() => {
                this.removeListener(releaseEvent, handler);
                reject(new Error("Timeout to acquire the connection."));
            }, this.timeout);
            this.once(releaseEvent, handler);
        });
    }
    /**
     * Closes all connections in the pool.
     * @see https://github.com/JoshuaWise/better-sqlite3/wiki/API#close---this
     */
    close() {
        this._closed = true;
        for (let id in this.connections) {
            const conn = this.connections[id];
            if (conn.available && conn.open) {
                conn.close();
            }
        }
    }
}
exports.Pool = Pool;
exports.default = Pool;
